<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>PartyGame - Play</title>
    <link rel="stylesheet" href="/css/styles.css">
    <style>
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .quiz-phone {
            max-width: 420px;
            margin: 0 auto;
            padding: 16px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .quiz-phone-header {
            background: rgba(255,255,255,0.1);
            border-radius: 16px;
            padding: 16px;
            margin-bottom: 16px;
            color: white;
            text-align: center;
        }

        .quiz-phone-header h2 {
            margin: 0 0 8px;
            font-size: 1.25rem;
        }

        .round-info {
            font-size: 0.875rem;
            opacity: 0.8;
            margin-bottom: 4px;
        }

        .timer-display {
            font-size: 2.5rem;
            font-weight: bold;
        }

        .timer-display.warning {
            color: #f1c40f;
            animation: blink 0.5s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .phase-indicator {
            font-size: 0.875rem;
            opacity: 0.8;
            margin-top: 4px;
        }

        /* Booster Card */
        .booster-card {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border-radius: 16px;
            padding: 12px 16px;
            margin-bottom: 16px;
            color: white;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 4px 15px rgba(240, 147, 251, 0.4);
        }

        .booster-card.used {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            opacity: 0.7;
            box-shadow: none;
        }

        .booster-icon {
            font-size: 2rem;
            flex-shrink: 0;
        }

        .booster-info {
            flex: 1;
            min-width: 0;
        }

        .booster-name {
            font-weight: bold;
            font-size: 1rem;
            margin-bottom: 2px;
        }

        .booster-description {
            font-size: 0.75rem;
            opacity: 0.9;
            line-height: 1.3;
        }

        .booster-status {
            font-size: 0.65rem;
            opacity: 0.7;
            margin-top: 4px;
        }

        .booster-activate-btn {
            background: white;
            color: #f5576c;
            border: none;
            border-radius: 12px;
            padding: 10px 16px;
            font-weight: bold;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .booster-activate-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .booster-activate-btn:disabled {
            background: rgba(255,255,255,0.3);
            color: rgba(255,255,255,0.7);
            cursor: not-allowed;
        }

        .booster-used-badge {
            background: rgba(255,255,255,0.2);
            padding: 8px 16px;
            border-radius: 12px;
            font-size: 0.75rem;
            flex-shrink: 0;
        }

        /* Target Selection Modal */
        .target-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
        }

        .target-modal-content {
            background: white;
            border-radius: 20px;
            padding: 24px;
            max-width: 320px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .target-modal-title {
            font-size: 1.25rem;
            font-weight: bold;
            margin-bottom: 8px;
            text-align: center;
        }

        .target-modal-subtitle {
            font-size: 0.875rem;
            color: var(--text-light);
            margin-bottom: 16px;
            text-align: center;
        }

        .target-player-btn {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: var(--bg-color);
            border: 2px solid transparent;
            border-radius: 12px;
            margin-bottom: 8px;
            cursor: pointer;
            width: 100%;
            text-align: left;
            transition: all 0.2s;
        }

        .target-player-btn:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .target-player-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .target-player-name {
            flex: 1;
            font-weight: 500;
        }

        .target-player-score {
            color: var(--text-light);
            font-size: 0.875rem;
        }

        .target-modal-cancel {
            width: 100%;
            padding: 12px;
            background: none;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            font-weight: 500;
            cursor: pointer;
            margin-top: 8px;
        }

        /* Toast Notification */
        .toast-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2000;
            pointer-events: none;
        }

        .toast {
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px 20px;
            border-radius: 12px;
            margin-bottom: 8px;
            animation: toastSlide 0.3s ease;
            text-align: center;
            max-width: 300px;
        }

        .toast.success {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
        }

        .toast.blocked {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
        }

        @keyframes toastSlide {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Category Selection */
        .category-selection-phone {
            background: white;
            border-radius: 20px;
            padding: 24px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .category-selection-title {
            text-align: center;
            font-size: 1.25rem;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .category-selection-subtitle {
            text-align: center;
            color: var(--text-light);
            margin-bottom: 20px;
        }

        .category-btn {
            border: 2px solid #e5e7eb;
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 12px;
            background: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 16px;
            transition: all 0.2s;
            width: 100%;
            text-align: left;
        }

        .category-btn:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .category-btn:active {
            transform: scale(0.98);
        }

        .category-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .category-btn.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .category-btn-icon {
            font-size: 2rem;
        }

        .category-btn-name {
            font-size: 1.125rem;
            font-weight: 600;
        }

        .waiting-for-leader {
            text-align: center;
            padding: 32px 16px;
        }

        .waiting-for-leader-icon {
            font-size: 3rem;
            margin-bottom: 12px;
        }

        .waiting-for-leader-text {
            font-size: 1.125rem;
            color: var(--text-light);
        }

        .waiting-for-leader-name {
            font-weight: bold;
            color: var(--text-color);
        }

        /* Question Card */
        .question-card-phone {
            background: white;
            border-radius: 20px;
            padding: 24px;
            margin-bottom: 16px;
            flex-shrink: 0;
        }

        .question-number {
            font-size: 0.875rem;
            color: var(--text-light);
            margin-bottom: 8px;
        }

        .current-category-badge {
            display: inline-block;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .question-text-phone {
            font-size: 1.125rem;
            font-weight: 600;
            line-height: 1.4;
        }

        /* Answer Buttons */
        .answer-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            flex: 1;
        }

        .answer-btn {
            border: none;
            border-radius: 16px;
            padding: 20px;
            font-size: 1.25rem;
            font-weight: bold;
            color: white;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s;
            min-height: 120px;
        }

        .answer-btn:active { transform: scale(0.95); }
        .answer-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .answer-btn.a { background: #e74c3c; }
        .answer-btn.b { background: #3498db; }
        .answer-btn.c { background: #f1c40f; color: #333; }
        .answer-btn.d { background: #2ecc71; }
        .answer-btn.selected { box-shadow: 0 0 0 4px white, 0 0 0 8px currentColor; }
        .answer-btn.correct { background: #27ae60 !important; color: white !important; }
        .answer-btn.incorrect { background: #95a5a6 !important; }
        .answer-btn.removed { opacity: 0.3; pointer-events: none; }

        .answer-key { font-size: 2rem; }
        .answer-text { font-size: 0.875rem; text-align: center; line-height: 1.2; }

        /* Waiting State */
        .waiting-state {
            background: white;
            border-radius: 20px;
            padding: 40px 24px;
            text-align: center;
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .waiting-icon { font-size: 4rem; margin-bottom: 16px; }
        .waiting-title { font-size: 1.5rem; font-weight: bold; margin-bottom: 8px; }
        .waiting-subtitle { color: var(--text-light); }

        /* Result State */
        .result-state {
            background: white;
            border-radius: 20px;
            padding: 32px 24px;
            text-align: center;
        }

        .result-icon { font-size: 5rem; margin-bottom: 16px; }
        .result-text { font-size: 1.5rem; font-weight: bold; margin-bottom: 8px; }
        .result-points { font-size: 1.125rem; color: var(--text-light); }
        .result-points.positive { color: var(--success-color); }

        /* Scoreboard Phone */
        .scoreboard-phone {
            background: white;
            border-radius: 20px;
            padding: 24px;
            flex: 1;
        }

        .scoreboard-phone-title { text-align: center; font-size: 1.25rem; font-weight: bold; margin-bottom: 16px; }

        .score-item {
            display: flex;
            align-items: center;
            padding: 12px;
            border-radius: 12px;
            margin-bottom: 8px;
            background: var(--bg-color);
        }

        .score-item.me {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .score-position { font-weight: bold; width: 32px; }
        .score-name { flex: 1; font-weight: 500; }
        .score-value { font-weight: bold; }

        /* Noped state */
        .noped-overlay {
            background: white;
            border-radius: 20px;
            padding: 40px 24px;
            text-align: center;
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .noped-icon { font-size: 4rem; margin-bottom: 16px; }
        .noped-title { font-size: 1.5rem; font-weight: bold; margin-bottom: 8px; color: #e74c3c; }
        .noped-subtitle { color: var(--text-light); }

        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div class="quiz-phone">
        <!-- Header -->
        <div class="quiz-phone-header">
            <h2>Quiz Time! üéØ</h2>
            <div class="round-info" id="roundInfo">Round 1</div>
            <div class="timer-display" id="timer">--</div>
            <div class="phase-indicator" id="phaseIndicator">Get ready...</div>
        </div>

        <!-- Booster Card -->
        <div class="booster-card hidden" id="boosterCard">
            <div class="booster-icon" id="boosterIcon">üéÅ</div>
            <div class="booster-info">
                <div class="booster-name" id="boosterName">Loading...</div>
                <div class="booster-description" id="boosterDescription">...</div>
                <div class="booster-status" id="boosterStatus"></div>
            </div>
            <button class="booster-activate-btn" id="boosterActivateBtn" onclick="onBoosterActivateClick()">
                Use
            </button>
            <div class="booster-used-badge hidden" id="boosterUsedBadge">‚úì Used</div>
        </div>

        <!-- Category Selection (for round leader) -->
        <div class="category-selection-phone hidden" id="categorySelectionState">
            <div class="category-selection-title">üéØ Choose a Category!</div>
            <div class="category-selection-subtitle" id="categorySubtitle">You're the round leader</div>
            <div id="categoryButtons">
                <!-- Category buttons will be inserted here -->
            </div>
        </div>

        <!-- Waiting for Category Selection (for non-leaders) -->
        <div class="waiting-state hidden" id="waitingForCategoryState">
            <div class="waiting-for-leader-icon">ü§î</div>
            <div class="waiting-title">Waiting for category...</div>
            <div class="waiting-for-leader-text">
                <span class="waiting-for-leader-name" id="leaderNameDisplay">Player</span> is choosing
            </div>
        </div>

        <!-- Question Display -->
        <div class="question-card-phone hidden" id="questionCard">
            <div class="current-category-badge" id="currentCategoryBadge">Category</div>
            <div class="question-number" id="questionNumber">Question 1 of 9</div>
            <div class="question-text-phone" id="questionText">Loading...</div>
        </div>

        <!-- Noped State (blocked from answering) -->
        <div class="noped-overlay hidden" id="nopedState">
            <div class="noped-icon">üö´</div>
            <div class="noped-title">Blocked!</div>
            <div class="noped-subtitle">Someone used NOPE on you.<br>You can't answer this question.</div>
        </div>

        <!-- Answer Buttons (shown during Answering phase) -->
        <div class="answer-buttons hidden" id="answerButtons">
            <button class="answer-btn a" data-key="A">
                <span class="answer-key">A</span>
                <span class="answer-text" id="optionA">...</span>
            </button>
            <button class="answer-btn b" data-key="B">
                <span class="answer-key">B</span>
                <span class="answer-text" id="optionB">...</span>
            </button>
            <button class="answer-btn c" data-key="C">
                <span class="answer-key">C</span>
                <span class="answer-text" id="optionC">...</span>
            </button>
            <button class="answer-btn d" data-key="D">
                <span class="answer-key">D</span>
                <span class="answer-text" id="optionD">...</span>
            </button>
        </div>

        <!-- Waiting State (shown during Question phase) -->
        <div class="waiting-state hidden" id="waitingState">
            <div class="waiting-icon">üëÄ</div>
            <div class="waiting-title">Watch the screen!</div>
            <div class="waiting-subtitle">Get ready to answer...</div>
        </div>

        <!-- Answer Submitted State -->
        <div class="waiting-state hidden" id="submittedState">
            <div class="waiting-icon">‚úì</div>
            <div class="waiting-title">Answer Received!</div>
            <div class="waiting-subtitle">Waiting for other players...</div>
        </div>

        <!-- Result State (shown during Reveal) -->
        <div class="result-state hidden" id="resultState">
            <div class="result-icon" id="resultIcon">‚úì</div>
            <div class="result-text" id="resultText">Correct!</div>
            <div class="result-points" id="resultPoints">+100 points</div>
        </div>

        <!-- Scoreboard (shown during Scoreboard phase) -->
        <div class="scoreboard-phone hidden" id="scoreboardState">
            <div class="scoreboard-phone-title" id="scoreboardTitle">üìä Scores</div>
            <div id="scoreboardList"></div>
        </div>

        <!-- Game Finished -->
        <div class="waiting-state hidden" id="finishedState">
            <div class="waiting-icon">üèÜ</div>
            <div class="waiting-title" id="finishedTitle">Game Over!</div>
            <div class="waiting-subtitle" id="finishedSubtitle">Thanks for playing!</div>
            <button class="btn btn-primary" style="margin-top: 24px;" onclick="window.location.href='/join.html'">
                Play Again
            </button>
        </div>
    </div>

    <!-- Target Selection Modal -->
    <div class="target-modal hidden" id="targetModal">
        <div class="target-modal-content">
            <div class="target-modal-title" id="targetModalTitle">Select Target</div>
            <div class="target-modal-subtitle" id="targetModalSubtitle">Choose a player</div>
            <div id="targetPlayerList"></div>
            <button class="target-modal-cancel" onclick="closeTargetModal()">Cancel</button>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- SignalR -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/8.0.0/signalr.min.js"></script>
    <script src="/js/config.js"></script>
    <script src="/js/game-client.js"></script>
    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const roomCode = urlParams.get('room');
        const playerIdParam = urlParams.get('playerId');

        if (!roomCode) {
            window.location.href = '/join.html';
        }

        const SERVER_URL = GameConfig.getServerUrl();
        const client = new GameClient(SERVER_URL);
        const playerId = playerIdParam || GameUtils.getPlayerId();
        const displayName = GameUtils.getStoredName() || 'Player';

        let selectedAnswer = null;
        let currentPhase = null;
        let previousPhase = null;
        let myScore = 0;
        let selectedCategory = null;
        let isSelectingCategory = false; // Debounce flag for category selection
        let currentState = null;
        let myBooster = null;
        let pendingBoosterActivation = null;
        
        // Smooth timer state
        let phaseEndsUtc = null;
        let timerIntervalId = null;

        // DOM Elements
        const roundInfoEl = document.getElementById('roundInfo');
        const timerEl = document.getElementById('timer');
        const phaseIndicatorEl = document.getElementById('phaseIndicator');
        const boosterCardEl = document.getElementById('boosterCard');
        const boosterIconEl = document.getElementById('boosterIcon');
        const boosterNameEl = document.getElementById('boosterName');
        const boosterDescriptionEl = document.getElementById('boosterDescription');
        const boosterStatusEl = document.getElementById('boosterStatus');
        const boosterActivateBtnEl = document.getElementById('boosterActivateBtn');
        const boosterUsedBadgeEl = document.getElementById('boosterUsedBadge');
        const categorySelectionStateEl = document.getElementById('categorySelectionState');
        const categorySubtitleEl = document.getElementById('categorySubtitle');
        const categoryButtonsEl = document.getElementById('categoryButtons');
        const waitingForCategoryStateEl = document.getElementById('waitingForCategoryState');
        const leaderNameDisplayEl = document.getElementById('leaderNameDisplay');
        const questionCardEl = document.getElementById('questionCard');
        const currentCategoryBadgeEl = document.getElementById('currentCategoryBadge');
        const questionNumberEl = document.getElementById('questionNumber');
        const questionTextEl = document.getElementById('questionText');
        const nopedStateEl = document.getElementById('nopedState');
        const answerButtonsEl = document.getElementById('answerButtons');
        const waitingStateEl = document.getElementById('waitingState');
        const submittedStateEl = document.getElementById('submittedState');
        const resultStateEl = document.getElementById('resultState');
        const resultIconEl = document.getElementById('resultIcon');
        const resultTextEl = document.getElementById('resultText');
        const resultPointsEl = document.getElementById('resultPoints');
        const scoreboardStateEl = document.getElementById('scoreboardState');
        const scoreboardTitleEl = document.getElementById('scoreboardTitle');
        const scoreboardListEl = document.getElementById('scoreboardList');
        const finishedStateEl = document.getElementById('finishedState');
        const finishedTitleEl = document.getElementById('finishedTitle');
        const finishedSubtitleEl = document.getElementById('finishedSubtitle');
        const targetModalEl = document.getElementById('targetModal');
        const targetModalTitleEl = document.getElementById('targetModalTitle');
        const targetModalSubtitleEl = document.getElementById('targetModalSubtitle');
        const targetPlayerListEl = document.getElementById('targetPlayerList');
        const toastContainerEl = document.getElementById('toastContainer');

        const categoryIcons = {
            'Wetenschap': 'üî¨', 'Science': 'üî¨',
            'Geschiedenis': 'üìú', 'History': 'üìú',
            'Geografie': 'üåç', 'Geography': 'üåç',
            'Sport': '‚öΩ', 'Sports': '‚öΩ',
            'Muziek': 'üéµ', 'Music': 'üéµ',
            'Film': 'üé¨', 'Films': 'üé¨', 'Movies': 'üé¨',
            'Natuur': 'üåø', 'Nature': 'üåø',
            'Kunst': 'üé®', 'Art': 'üé®',
            'Literatuur': 'üìö', 'Literature': 'üìö',
            'Technologie': 'üíª', 'Technology': 'üíª',
            'Eten & Drinken': 'üçï', 'Food': 'üçï',
            'default': '‚ùì'
        };

        function getCategoryIcon(category) {
            return categoryIcons[category] || categoryIcons['default'];
        }

        // Answer buttons
        const answerBtns = document.querySelectorAll('.answer-btn');
        answerBtns.forEach(btn => {
            btn.addEventListener('click', () => submitAnswer(btn.dataset.key));
        });

        async function init() {
            client.on('onConnected', () => console.log('Connected'));
            client.on('onQuizStateUpdated', onQuizStateUpdated);
            client.on('onBoosterActivated', onBoosterActivated);
            client.on('onError', (error) => {
                console.error('Error:', error);
                showToast(GameUtils.formatError(error), 'error');
            });

            await client.connect();
            await client.joinRoom(roomCode, playerId, displayName);
            
            // Start smooth timer loop
            startTimerLoop();
        }
        
        // Smooth timer functions
        function startTimerLoop() {
            if (timerIntervalId) clearInterval(timerIntervalId);
            timerIntervalId = setInterval(updateTimerDisplay, 200);
        }
        
        function updateTimerDisplay() {
            if (!phaseEndsUtc) {
                timerEl.textContent = '--';
                timerEl.classList.remove('warning');
                return;
            }
            
            const now = Date.now();
            const remaining = Math.max(0, Math.ceil((phaseEndsUtc - now) / 1000));
            timerEl.textContent = remaining;
            timerEl.classList.toggle('warning', remaining <= 5);
        }

        function onQuizStateUpdated(state) {
            console.log('Quiz state:', state);
            currentState = state;

            // Update header
            roundInfoEl.textContent = `Round ${state.roundNumber || 1}${state.currentCategory ? ` - ${state.currentCategory}` : ''}`;
            
            // Update phaseEndsUtc for smooth timer
            if (state.phaseEndsUtc) {
                phaseEndsUtc = new Date(state.phaseEndsUtc).getTime();
            } else if (state.remainingSeconds !== undefined) {
                phaseEndsUtc = Date.now() + (state.remainingSeconds * 1000);
            }
            updateTimerDisplay();

            // Get phase
            const phaseMap = { 'CategorySelection': 0, 'Question': 1, 'Answering': 2, 'Reveal': 3, 'Scoreboard': 4, 'Finished': 5 };
            const phase = typeof state.phase === 'number' ? state.phase : (phaseMap[state.phase] ?? state.phase);
            
            // Detect phase transition - reset category selection state when entering CategorySelection
            if (phase === 0 && currentPhase !== 0) {
                selectedCategory = null;
                isSelectingCategory = false;
            }
            
            previousPhase = currentPhase;
            currentPhase = phase;

            // Update phase indicator
            const phaseNames = ['Choose category', 'Reading question...', 'Answer now!', 'Revealing...', 'Scoreboard', 'Game Over'];
            phaseIndicatorEl.textContent = phaseNames[phase] || state.phase;

            // Update question info
            questionNumberEl.textContent = `Question ${state.questionNumber || '-'} of ${state.totalQuestions}`;
            questionTextEl.textContent = state.questionText || '';

            if (state.currentCategory) {
                currentCategoryBadgeEl.textContent = `${getCategoryIcon(state.currentCategory)} ${state.currentCategory}`;
                currentCategoryBadgeEl.style.display = 'inline-block';
            } else {
                currentCategoryBadgeEl.style.display = 'none';
            }

            // Update options
            (state.options || []).forEach(opt => {
                const el = document.getElementById('option' + opt.key);
                if (el) el.textContent = opt.text;
            });

            // Find my status
            const myStatus = (state.answerStatuses || []).find(s => s.playerId === playerId);
            const myScoreData = (state.scoreboard || []).find(s => s.playerId === playerId);
            if (myScoreData) myScore = myScoreData.score;

            // Update booster UI
            updateBoosterUI(state);

            // Handle different phases
            if (phase === 5) { // Finished
                showFinished(state);
            } else if (phase === 4) { // Scoreboard
                showScoreboard(state);
            } else if (phase === 3) { // Reveal
                showReveal(state, myScoreData);
            } else if (phase === 2) { // Answering
                // Check if noped
                const myEffects = state.myAnsweringEffects;
                if (myEffects?.isNoped) {
                    showNoped();
                } else if (myStatus?.hasAnswered) {
                    showSubmitted();
                } else {
                    showAnswering(state);
                }
            } else if (phase === 1) { // Question
                showWaiting();
            } else if (phase === 0) { // CategorySelection
                showCategorySelection(state);
            }
        }

        function updateBoosterUI(state) {
            // Find my booster
            myBooster = (state.playerBoosters || []).find(b => b.playerId === playerId);
            
            if (!myBooster) {
                boosterCardEl.classList.add('hidden');
                return;
            }

            boosterCardEl.classList.remove('hidden');
            boosterCardEl.classList.toggle('used', myBooster.isUsed);
            
            // Get booster type as number
            const boosterTypeNum = typeof myBooster.boosterType === 'number' 
                ? myBooster.boosterType 
                : GameUtils.BoosterTypes[myBooster.boosterType] ?? 0;
            
            boosterIconEl.textContent = GameUtils.getBoosterEmoji(boosterTypeNum);
            boosterNameEl.textContent = myBooster.boosterName || 'Unknown Booster';
            boosterDescriptionEl.textContent = myBooster.boosterDescription || '';
            
            if (myBooster.isUsed) {
                boosterActivateBtnEl.classList.add('hidden');
                boosterUsedBadgeEl.classList.remove('hidden');
                boosterStatusEl.textContent = '';
            } else {
                boosterActivateBtnEl.classList.remove('hidden');
                boosterUsedBadgeEl.classList.add('hidden');
                
                // Check if can activate in current phase
                const canActivate = canActivateBooster(state, myBooster);
                boosterActivateBtnEl.disabled = !canActivate;
                
                if (canActivate) {
                    boosterStatusEl.textContent = '‚ú® Ready to use!';
                } else {
                    const validPhases = (myBooster.validPhases || []).join(', ');
                    boosterStatusEl.textContent = `Use during: ${validPhases}`;
                }
            }
        }

        function canActivateBooster(state, booster) {
            if (!booster || booster.isUsed) return false;
            
            // Get current phase name
            const phaseNames = ['CategorySelection', 'Question', 'Answering', 'Reveal', 'Scoreboard', 'Finished'];
            const currentPhaseName = phaseNames[currentPhase] || '';
            
            // Check if current phase is in valid phases
            const validPhases = booster.validPhases || [];
            return validPhases.includes(currentPhaseName);
        }

        function onBoosterActivateClick() {
            if (!myBooster || myBooster.isUsed) return;
            
            const boosterTypeNum = typeof myBooster.boosterType === 'number' 
                ? myBooster.boosterType 
                : GameUtils.BoosterTypes[myBooster.boosterType] ?? 0;
            
            if (myBooster.requiresTarget) {
                showTargetModal(boosterTypeNum);
            } else {
                activateBooster(boosterTypeNum, null);
            }
        }

        function showTargetModal(boosterType) {
            pendingBoosterActivation = boosterType;
            
            // Get other players from scoreboard
            const otherPlayers = (currentState?.scoreboard || []).filter(p => p.playerId !== playerId);
            
            targetModalTitleEl.textContent = `${myBooster.boosterName}`;
            targetModalSubtitleEl.textContent = 'Select a target player';
            
            targetPlayerListEl.innerHTML = otherPlayers.map(player => `
                <button class="target-player-btn" onclick="selectTarget('${player.playerId}')">
                    <div class="target-player-avatar">${GameUtils.getInitials(player.displayName)}</div>
                    <div class="target-player-name">${escapeHtml(player.displayName)}</div>
                    <div class="target-player-score">${player.score} pts</div>
                </button>
            `).join('');
            
            targetModalEl.classList.remove('hidden');
        }

        function closeTargetModal() {
            targetModalEl.classList.add('hidden');
            pendingBoosterActivation = null;
        }

        function selectTarget(targetId) {
            if (pendingBoosterActivation !== null) {
                activateBooster(pendingBoosterActivation, targetId);
            }
            closeTargetModal();
        }

        async function activateBooster(boosterType, targetId) {
            try {
                await client.activateBooster(boosterType, targetId);
            } catch (error) {
                console.error('Failed to activate booster:', error);
                showToast('Failed to activate booster', 'error');
            }
        }

        function onBoosterActivated(event) {
            console.log('Booster activated event:', event);
            
            let message;
            let toastClass = 'success';
            
            const emoji = GameUtils.getBoosterEmoji(typeof event.boosterType === 'number' 
                ? event.boosterType 
                : GameUtils.BoosterTypes[event.boosterType] ?? 0);
            
            if (event.wasBlockedByShield) {
                message = `${emoji} ${event.activatorName}'s ${event.boosterName} was blocked by ${event.shieldBlockerName}'s Shield! üõ°Ô∏è`;
                toastClass = 'blocked';
            } else if (event.targetName) {
                message = `${emoji} ${event.activatorName} used ${event.boosterName} on ${event.targetName}!`;
            } else {
                message = `${emoji} ${event.activatorName} activated ${event.boosterName}!`;
            }
            
            showToast(message, toastClass);
        }

        function showToast(message, type = 'default') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            toastContainerEl.appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateY(-20px)';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        /* Category selection */
        let debounceTimeout = null;

        function showCategorySelection(state) {
            hideAll();
            
            const isRoundLeader = state.roundLeaderPlayerId === playerId;
            const leader = (state.scoreboard || []).find(p => p.playerId === state.roundLeaderPlayerId);
            
            if (isRoundLeader) {
                categorySelectionStateEl.classList.remove('hidden');
                categorySubtitleEl.textContent = "You're the round leader!";
                
                // Render category buttons
                const categories = state.availableCategories || [];
                categoryButtonsEl.innerHTML = categories.map(cat => `
                    <button class="category-btn ${selectedCategory === cat ? 'selected' : ''}" data-category="${cat}">
                        <span class="category-btn-icon">${getCategoryIcon(cat)}</span>
                        <span class="category-btn-name">${escapeHtml(cat)}</span>
                    </button>
                `).join('');

                // Add click handlers
                document.querySelectorAll('.category-btn').forEach(btn => {
                    btn.addEventListener('click', () => selectCategory(btn.dataset.category));
                });
            } else {
                waitingForCategoryStateEl.classList.remove('hidden');
                leaderNameDisplayEl.textContent = leader?.displayName || 'Someone';
            }
        }

        async function selectCategory(category) {
            // Only allow in CategorySelection phase
            if (currentPhase !== 0) return;
            
            // Debounce: prevent multiple rapid clicks during request
            if (isSelectingCategory) return;
            
            isSelectingCategory = true;
            selectedCategory = category;
            
            // UI: highlight selection and temporarily disable buttons during request
            document.querySelectorAll('.category-btn').forEach(btn => {
                btn.classList.toggle('selected', btn.dataset.category === category);
                btn.disabled = true; // Temporarily disable during request
            });

            try {
                await client.selectCategory(category);
                // Success: buttons stay disabled until server changes phase
                // (hideAll() will be called when phase changes)
            } catch (error) {
                console.error('Failed to select category:', error);
                // On error: reset state so user can try again
                selectedCategory = null;
                document.querySelectorAll('.category-btn').forEach(btn => {
                    btn.disabled = false;
                    btn.classList.remove('selected');
                });
            } finally {
                isSelectingCategory = false;
            }
        }

        function showWaiting() {
            hideAll();
            questionCardEl.classList.remove('hidden');
            waitingStateEl.classList.remove('hidden');
            selectedAnswer = null;
        }

        function showNoped() {
            hideAll();
            questionCardEl.classList.remove('hidden');
            nopedStateEl.classList.remove('hidden');
        }

        function showAnswering(state) {
            hideAll();
            questionCardEl.classList.remove('hidden');
            answerButtonsEl.classList.remove('hidden');

            // Check for 50/50 effect
            const removedOptions = state.myAnsweringEffects?.removedOptions || [];

            answerBtns.forEach(btn => {
                btn.disabled = false;
                btn.classList.remove('selected', 'correct', 'incorrect', 'removed');
                
                // Apply 50/50 effect
                if (removedOptions.includes(btn.dataset.key)) {
                    btn.classList.add('removed');
                    btn.disabled = true;
                }
            });
            selectedAnswer = null;
        }

        function showSubmitted() {
            hideAll();
            questionCardEl.classList.remove('hidden');
            submittedStateEl.classList.remove('hidden');
        }

        function showReveal(state, myScoreData) {
            hideAll();
            questionCardEl.classList.remove('hidden');
            resultStateEl.classList.remove('hidden');

            const wasCorrect = myScoreData?.answeredCorrectly === true;
            const pointsEarned = myScoreData?.pointsEarned || 0;
            
            resultIconEl.textContent = wasCorrect ? '‚úì' : '‚úó';
            resultTextEl.textContent = wasCorrect ? 'Correct!' : 'Wrong!';
            resultPointsEl.textContent = pointsEarned > 0 ? `+${pointsEarned} points` : '+0 points';
            resultPointsEl.classList.toggle('positive', pointsEarned > 0);

            answerButtonsEl.classList.remove('hidden');
            answerBtns.forEach(btn => {
                btn.disabled = true;
                const key = btn.dataset.key;
                btn.classList.remove('selected', 'removed');
                
                if (key === state.correctOptionKey) {
                    btn.classList.add('correct');
                } else if (key === myScoreData?.selectedOption) {
                    btn.classList.add('incorrect');
                }
            });
        }

        function showScoreboard(state) {
            hideAll();
            scoreboardStateEl.classList.remove('hidden');

            scoreboardTitleEl.textContent = state.questionNumber >= state.totalQuestions 
                ? 'üèÜ Final Scores' : 'üìä Scores';

            scoreboardListEl.innerHTML = (state.scoreboard || []).map(player => {
                const isMe = player.playerId === playerId;
                const emoji = player.position === 1 ? 'ü•á' : 
                             player.position === 2 ? 'ü•à' : 
                             player.position === 3 ? 'ü•â' : `#${player.position}`;

                return `
                    <div class="score-item ${isMe ? 'me' : ''}">
                        <div class="score-position">${emoji}</div>
                        <div class="score-name">${escapeHtml(player.displayName)}${isMe ? ' (You)' : ''}</div>
                        <div class="score-value">${player.score}</div>
                    </div>
                `;
            }).join('');
        }

        function showFinished(state) {
            hideAll();
            finishedStateEl.classList.remove('hidden');

            const myPosition = (state.scoreboard || []).findIndex(s => s.playerId === playerId) + 1;
            const winner = state.scoreboard?.[0];

            if (myPosition === 1) {
                finishedTitleEl.textContent = 'üèÜ You Won!';
                finishedSubtitleEl.textContent = `${myScore} points`;
            } else {
                finishedTitleEl.textContent = `You finished #${myPosition}`;
                finishedSubtitleEl.textContent = `${myScore} points - Winner: ${winner?.displayName || 'Unknown'}`;
            }
        }

        function hideAll() {
            categorySelectionStateEl.classList.add('hidden');
            waitingForCategoryStateEl.classList.add('hidden');
            questionCardEl.classList.add('hidden');
            waitingStateEl.classList.add('hidden');
            nopedStateEl.classList.add('hidden');
            submittedStateEl.classList.add('hidden');
            answerButtonsEl.classList.add('hidden');
            resultStateEl.classList.add('hidden');
            scoreboardStateEl.classList.add('hidden');
            finishedStateEl.classList.add('hidden');
        }

        async function submitAnswer(key) {
            if (selectedAnswer || currentPhase !== 2) return;

            selectedAnswer = key;
            
            answerBtns.forEach(btn => {
                btn.disabled = true;
                if (btn.dataset.key === key) {
                    btn.classList.add('selected');
                }
            });

            try {
                await client.submitAnswer(key);
                showSubmitted();
            } catch (error) {
                console.error('Failed to submit answer:', error);
                selectedAnswer = null;
                answerBtns.forEach(btn => {
                    btn.disabled = false;
                    btn.classList.remove('selected');
                });
            }
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        init();
    </script>
</body>
</html>
